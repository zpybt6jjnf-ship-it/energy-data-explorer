import { useMemo, useState, useEffect } from 'react'
import Plot from 'react-plotly.js'
import { OutageEventData } from '../../types'
import { COLORS, baseLayout, baseConfig } from '../../utils/plotly'
import { downloadGenericCSV, downloadGenericJSON } from '../../utils/export'
import { ChartControlsWrapper } from '../controls'

interface Props {
  yearStart: number
  yearEnd: number
  yearsAvailable: number[]
  onYearStartChange: (year: number) => void
  onYearEndChange: (year: number) => void
}

/**
 * Choropleth map showing weather vulnerability by state.
 * Color intensity represents weather-driven outage frequency.
 */
export default function WeatherVulnerabilityMap({
  yearStart,
  yearEnd,
  yearsAvailable,
  onYearStartChange,
  onYearEndChange
}: Props) {
  const [outageData, setOutageData] = useState<OutageEventData | null>(null)
  const [loading, setLoading] = useState(true)
  const [metric, setMetric] = useState<'events' | 'rate'>('events')

  // Load outage data
  useEffect(() => {
    fetch('/data/outage-events.json')
      .then(res => res.json())
      .then(data => {
        setOutageData(data)
        setLoading(false)
      })
      .catch(err => {
        console.error('Failed to load outage data:', err)
        setLoading(false)
      })
  }, [])

  // Calculate state-level weather event metrics
  const stateMetrics = useMemo(() => {
    if (!outageData) return new Map()

    const byState = new Map<string, {
      totalEvents: number
      weatherEvents: number
      totalCustomers: number
      years: number
    }>()

    outageData.stateYearSummary.forEach(s => {
      if (s.year < yearStart || s.year > yearEnd) return

      if (!byState.has(s.stateCode)) {
        byState.set(s.stateCode, {
          totalEvents: 0,
          weatherEvents: 0,
          totalCustomers: 0,
          years: 0
        })
      }

      const state = byState.get(s.stateCode)!
      state.totalEvents += s.totalEvents
      state.weatherEvents += s.weatherEvents
      state.totalCustomers += s.totalCustomersAffected
      state.years += 1
    })

    return byState
  }, [outageData, yearStart, yearEnd])

  // Prepare map data
  const mapData = useMemo(() => {
    const states: string[] = []
    const values: number[] = []
    const hoverText: string[] = []

    stateMetrics.forEach((data, stateCode) => {
      states.push(stateCode)

      let value: number
      if (metric === 'events') {
        value = data.weatherEvents
      } else {
        // Rate = weather events per year
        value = data.years > 0 ? data.weatherEvents / data.years : 0
      }
      values.push(value)

      const weatherPct = data.totalEvents > 0
        ? (data.weatherEvents / data.totalEvents * 100).toFixed(0)
        : '0'

      hoverText.push(
        `<b>${stateCode}</b><br>` +
        `Weather Events: ${data.weatherEvents}<br>` +
        `Total Events: ${data.totalEvents}<br>` +
        `Weather Share: ${weatherPct}%<br>` +
        `Customers Affected: ${data.totalCustomers.toLocaleString()}`
      )
    })

    return { states, values, hoverText }
  }, [stateMetrics, metric])

  const plotData = useMemo(() => [{
    type: 'choropleth' as const,
    locationmode: 'USA-states' as const,
    locations: mapData.states,
    z: mapData.values,
    text: mapData.hoverText,
    hoverinfo: 'text' as const,
    colorscale: [
      [0, '#f7fbff'],
      [0.25, '#c6dbef'],
      [0.5, '#6baed6'],
      [0.75, '#2171b5'],
      [1, '#08306b']
    ] as Array<[number, string]>,
    colorbar: {
      title: { text: metric === 'events' ? 'Weather Events' : 'Events/Year' },
      thickness: 15,
      len: 0.7
    },
    marker: {
      line: {
        color: COLORS.ink,
        width: 0.5
      }
    }
  }], [mapData, metric])

  const layout = useMemo(() => ({
    ...baseLayout,
    title: { text: '' },
    geo: {
      scope: 'usa' as const,
      showlakes: true,
      lakecolor: 'rgb(255, 255, 255)',
      bgcolor: 'rgba(0,0,0,0)'
    },
    dragmode: false as const,
    margin: { t: 20, b: 20, l: 20, r: 20 }
  }), [])

  const plotConfig = {
    ...baseConfig,
    toImageButtonOptions: {
      format: 'png' as const,
      filename: `weather-vulnerability-${yearStart}-${yearEnd}`,
      height: 500,
      width: 800,
      scale: 2
    }
  }

  // Export data
  const exportData = Array.from(stateMetrics.entries()).map(([stateCode, data]) => ({
    state: stateCode,
    weather_events: data.weatherEvents,
    total_events: data.totalEvents,
    weather_pct: data.totalEvents > 0 ? Math.round(data.weatherEvents / data.totalEvents * 100) : 0,
    customers_affected: data.totalCustomers,
    events_per_year: data.years > 0 ? Math.round(data.weatherEvents / data.years * 10) / 10 : 0
  }))

  // Top vulnerable states
  const topStates = useMemo(() => {
    return Array.from(stateMetrics.entries())
      .sort((a, b) => b[1].weatherEvents - a[1].weatherEvents)
      .slice(0, 5)
      .map(([state, data]) => ({ state, events: data.weatherEvents }))
  }, [stateMetrics])

  if (loading) {
    return <div className="chart-container"><div className="loading">Loading outage data...</div></div>
  }

  return (
    <div className="chart-container" role="figure" aria-label="Choropleth map showing weather vulnerability by state.">
      <div className="chart-header">
        <h2>Weather Vulnerability Map</h2>
        <p>
          Which states experience the most weather-related power outages?
        </p>
      </div>

      <details className="chart-description">
        <summary>About this chart</summary>
        <div className="chart-description-content">
          <div className="description-section">
            <h3>What does this show?</h3>
            <p>
              Darker colors indicate states with more weather-driven major power outages.
              Weather events include storms, hurricanes, extreme temperatures, ice, and floods.
            </p>
          </div>
          <div className="description-section">
            <h3>Regional patterns</h3>
            <p>
              Gulf Coast and Southeast states typically show high vulnerability due to
              hurricanes and severe thunderstorms. Northern states may show elevated
              levels from ice storms and extreme cold events.
            </p>
          </div>
        </div>
      </details>

      <ChartControlsWrapper>
        <div className="control-group">
          <label>Start Year</label>
          <select value={yearStart} onChange={(e) => onYearStartChange(parseInt(e.target.value))}>
            {yearsAvailable.filter(y => y < yearEnd).map(y => (
              <option key={y} value={y}>{y}</option>
            ))}
          </select>
        </div>

        <div className="control-group">
          <label>End Year</label>
          <select value={yearEnd} onChange={(e) => onYearEndChange(parseInt(e.target.value))}>
            {yearsAvailable.filter(y => y > yearStart).map(y => (
              <option key={y} value={y}>{y}</option>
            ))}
          </select>
        </div>

        <div className="control-group">
          <label>Metric</label>
          <select value={metric} onChange={(e) => setMetric(e.target.value as 'events' | 'rate')}>
            <option value="events">Total Events</option>
            <option value="rate">Events per Year</option>
          </select>
        </div>

        <div className="control-group">
          <label>Export</label>
          <div className="button-group">
            <button onClick={() => downloadGenericCSV(exportData, `weather-vulnerability-${yearStart}-${yearEnd}`)}>
              CSV
            </button>
            <button onClick={() => downloadGenericJSON(exportData, `weather-vulnerability-${yearStart}-${yearEnd}`)}>
              JSON
            </button>
          </div>
        </div>
      </ChartControlsWrapper>

      <div className="stats-panel">
        <div className="stats-summary">
          <p className="summary-main">
            Most vulnerable states ({yearStart}â€“{yearEnd}):
          </p>
          <p className="summary-detail">
            {topStates.map(s => `${s.state} (${s.events})`).join(', ')}
          </p>
        </div>
      </div>

      <div className="chart-plot-wrapper">
        <Plot
          data={plotData}
          layout={layout}
          config={plotConfig}
          style={{ width: '100%', height: '450px' }}
        />
      </div>
    </div>
  )
}
